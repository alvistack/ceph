diff --git a/src/SimpleRADOSStriper.cc b/src/SimpleRADOSStriper.cc
index 66bc653fb7c..aed33d0ad09 100644
--- a/src/SimpleRADOSStriper.cc
+++ b/src/SimpleRADOSStriper.cc
@@ -140,7 +140,7 @@ int SimpleRADOSStriper::remove()
   return 0;
 }
 
-int SimpleRADOSStriper::truncate(uint64_t size)
+int SimpleRADOSStriper::truncate(size_t size)
 {
   d(5) << size << dendl;
 
diff --git a/src/os/bluestore/BlueFS.cc b/src/os/bluestore/BlueFS.cc
index f462fa88648..a609c59a378 100644
--- a/src/os/bluestore/BlueFS.cc
+++ b/src/os/bluestore/BlueFS.cc
@@ -3831,11 +3831,11 @@ int BlueFS::do_replay_recovery_read(FileReader *log_reader,
 
 size_t BlueFS::probe_alloc_avail(int dev, uint64_t alloc_size)
 {
-  size_t total = 0;
-  auto iterated_allocation = [&](size_t off, size_t len) {
+  uint64_t total = 0;
+  auto iterated_allocation = [&](uint64_t off, uint64_t len) {
     //only count in size that is alloc_size aligned
-    size_t dist_to_alignment;
-    size_t offset_in_block = off & (alloc_size - 1);
+    uint64_t dist_to_alignment;
+    uint64_t offset_in_block = off & (alloc_size - 1);
     if (offset_in_block == 0)
       dist_to_alignment = 0;
     else
diff --git a/src/test/libcephfs/ceph_pthread_self.h b/src/test/libcephfs/ceph_pthread_self.h
index 4c0c98f6ee3..9e3cdfa99e2 100644
--- a/src/test/libcephfs/ceph_pthread_self.h
+++ b/src/test/libcephfs/ceph_pthread_self.h
@@ -25,7 +25,7 @@ static uint64_t ceph_pthread_self() {
   static_assert(std::is_convertible_v<decltype(me), uint64_t> ||
                 std::is_pointer_v<decltype(me)>,
                 "we need to use pthread_self() for the owner parameter");
-  return reinterpret_cast<uint64_t>(me);
+  return static_cast<uint64_t>(me);
 }
 
 #endif
diff --git a/src/tools/cephfs_mirror/FSMirror.cc b/src/tools/cephfs_mirror/FSMirror.cc
index 76dcc11f6c6..9e9cfe72762 100644
--- a/src/tools/cephfs_mirror/FSMirror.cc
+++ b/src/tools/cephfs_mirror/FSMirror.cc
@@ -345,7 +345,7 @@ void FSMirror::handle_acquire_directory(string_view dir_path) {
     std::scoped_lock locker(m_lock);
     m_directories.emplace(dir_path);
     m_service_daemon->add_or_update_fs_attribute(m_filesystem.fscid, SERVICE_DAEMON_DIR_COUNT_KEY,
-                                                 m_directories.size());
+                                                 static_cast<uint64_t>(m_directories.size()));
 
     for (auto &[peer, peer_replayer] : m_peer_replayers) {
       dout(10) << ": peer=" << peer << dendl;
@@ -363,7 +363,7 @@ void FSMirror::handle_release_directory(string_view dir_path) {
     if (it != m_directories.end()) {
       m_directories.erase(it);
       m_service_daemon->add_or_update_fs_attribute(m_filesystem.fscid, SERVICE_DAEMON_DIR_COUNT_KEY,
-                                                   m_directories.size());
+                                                   static_cast<uint64_t>(m_directories.size()));
       for (auto &[peer, peer_replayer] : m_peer_replayers) {
         dout(10) << ": peer=" << peer << dendl;
         peer_replayer->remove_directory(dir_path);
diff --git a/src/tools/neorados.cc b/src/tools/neorados.cc
index 516dfbce7fe..822335d513f 100644
--- a/src/tools/neorados.cc
+++ b/src/tools/neorados.cc
@@ -146,7 +146,7 @@ void create(R::RADOS& r, const std::vector<std::string>& p,
 			     obj, pname));
 }
 
-inline constexpr std::size_t io_size = 4 << 20;
+inline constexpr std::uint64_t io_size = 4 << 20;
 
 void write(R::RADOS& r, const std::vector<std::string>& p, s::yield_context y)
 {
@@ -156,7 +156,7 @@ void write(R::RADOS& r, const std::vector<std::string>& p, s::yield_context y)
 
   bs::error_code ec;
   std::unique_ptr<char[]> buf = std::make_unique<char[]>(io_size);
-  std::size_t off = 0;
+  std::uint64_t off = 0;
   boost::io::ios_exception_saver ies(std::cin);
 
   std::cin.exceptions(std::istream::badbit);
@@ -203,7 +203,7 @@ void read(R::RADOS& r, const std::vector<std::string>& p, s::yield_context y)
 		    obj, pname));
   }
 
-  std::size_t off = 0;
+  std::uint64_t off = 0;
   ceph::buffer::list bl;
   while (auto toread = std::max(len - off, io_size)) {
     R::ReadOp op;
diff --git a/src/tools/rbd_mirror/image_replayer/snapshot/Replayer.cc b/src/tools/rbd_mirror/image_replayer/snapshot/Replayer.cc
index ce803ed2203..b9098e30859 100644
--- a/src/tools/rbd_mirror/image_replayer/snapshot/Replayer.cc
+++ b/src/tools/rbd_mirror/image_replayer/snapshot/Replayer.cc
@@ -253,7 +253,8 @@ bool Replayer<I>::get_replay_status(std::string* description,
 
   json_spirit::mObject root_obj;
   root_obj["replay_state"] = replay_state;
-  root_obj["remote_snapshot_timestamp"] = remote_snap_info->timestamp.sec();
+  root_obj["remote_snapshot_timestamp"] = static_cast<uint64_t>(
+    remote_snap_info->timestamp.sec());
 
   auto matching_remote_snap_id = util::compute_remote_snap_id(
     m_state_builder->local_image_ctx->image_lock,
@@ -267,8 +268,8 @@ bool Replayer<I>::get_replay_status(std::string* description,
     // use the timestamp from the matching remote image since
     // the local snapshot would just be the time the snapshot was
     // synced and not the consistency point in time.
-    root_obj["local_snapshot_timestamp"] =
-      matching_remote_snap_it->second.timestamp.sec();
+    root_obj["local_snapshot_timestamp"] = static_cast<uint64_t>(
+      matching_remote_snap_it->second.timestamp.sec());
   }
 
   matching_remote_snap_it = m_state_builder->remote_image_ctx->snap_info.find(
@@ -276,7 +277,8 @@ bool Replayer<I>::get_replay_status(std::string* description,
   if (m_remote_snap_id_end != CEPH_NOSNAP &&
       matching_remote_snap_it !=
         m_state_builder->remote_image_ctx->snap_info.end()) {
-    root_obj["syncing_snapshot_timestamp"] = remote_snap_info->timestamp.sec();
+    root_obj["syncing_snapshot_timestamp"] = static_cast<uint64_t>(
+        remote_snap_info->timestamp.sec());
 
     if (m_local_object_count > 0) {
       root_obj["syncing_percent"] =
